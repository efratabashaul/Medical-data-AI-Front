/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2020 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */
!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("pdfjs-dist/build/pdf.worker", [], t) : "object" == typeof exports ? exports["pdfjs-dist/build/pdf.worker"] = t() : e["pdfjs-dist/build/pdf.worker"] = e.pdfjsWorker = t() }(this, (function () { return function (e) { var t = {}; function a(r) { if (t[r]) return t[r].exports; var i = t[r] = { i: r, l: !1, exports: {} }; e[r].call(i.exports, i, i.exports, a); i.l = !0; return i.exports } a.m = e; a.c = t; a.d = function (e, t, r) { a.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }; a.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }); Object.defineProperty(e, "__esModule", { value: !0 }) }; a.t = function (e, t) { 1 & t && (e = a(e)); if (8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var r = Object.create(null); a.r(r); Object.defineProperty(r, "default", { enumerable: !0, value: e }); if (2 & t && "string" != typeof e) for (var i in e) a.d(r, i, function (t) { return e[t] }.bind(null, i)); return r }; a.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; a.d(t, "a", t); return t }; a.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }; a.p = ""; return a(a.s = 0) }([function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); Object.defineProperty(t, "WorkerMessageHandler", { enumerable: !0, get: function () { return r.WorkerMessageHandler } }); var r = a(1) }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.WorkerMessageHandler = t.WorkerTask = void 0; var r = a(2), i = a(5), n = a(6), s = a(4), o = a(45), c = a(46), l = a(8), h = function () { function e(e) { this.name = e; this.terminated = !1; this._capability = (0, r.createPromiseCapability)() } e.prototype = { get finished() { return this._capability.promise }, finish() { this._capability.resolve() }, terminate() { this.terminated = !0 }, ensureNotTerminated() { if (this.terminated) throw new Error("Worker task was terminated") } }; return e }(); t.WorkerTask = h; var u, d = { setup(e, t) { var a = !1; e.on("test", (function (t) { if (a) return; a = !0; if (!(t instanceof Uint8Array)) { e.send("test", null); return } const r = 255 === t[0]; e.postMessageTransfers = r; e.send("test", { supportTransfers: r }) })); e.on("configure", (function (e) { (0, r.setVerbosityLevel)(e.verbosity) })); e.on("GetDocRequest", (function (e) { return d.createDocumentHandler(e, t) })) }, createDocumentHandler(e, t) { var a, s = !1, u = null, d = []; const f = (0, r.getVerbosityLevel)(), g = e.apiVersion; if ("2.5.207" !== g) throw new Error(`The API version "${g}" does not match the Worker version "2.5.207".`); const m = []; for (const e in []) m.push(e); if (m.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + m.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s."); if ("undefined" == typeof ReadableStream || void 0 === Promise.allSettled) throw new Error("The browser/environment lacks native support for critical functionality used by the PDF.js library (e.g. `ReadableStream` and/or `Promise.allSettled`); please use an ES5-compatible build instead."); var p = e.docId, b = e.docBaseUrl, y = e.docId + "_worker", v = new o.MessageHandler(y, p, t); v.postMessageTransfers = e.postMessageTransfers; function w() { if (s) throw new Error("Worker was terminated") } function k(e) { d.push(e) } function S(e) { e.finish(); var t = d.indexOf(e); d.splice(t, 1) } async function C(e) { await a.ensureDoc("checkHeader"); await a.ensureDoc("parseStartXRef"); await a.ensureDoc("parse", [e]); e || await a.ensureDoc("checkFirstPage"); const [t, r] = await Promise.all([a.ensureDoc("numPages"), a.ensureDoc("fingerprint")]); return { numPages: t, fingerprint: r } } function x(e, t) { var a = (0, r.createPromiseCapability)(); let i; var s = e.source; if (s.data) { try { i = new n.LocalPdfManager(p, s.data, s.password, t, b); a.resolve(i) } catch (e) { a.reject(e) } return a.promise } var o, l = []; try { o = new c.PDFWorkerStream(v) } catch (e) { a.reject(e); return a.promise } var h = o.getFullReader(); h.headersReady.then((function () { if (h.isRangeSupported) { var e = s.disableAutoFetch || h.isStreamingSupported; i = new n.NetworkPdfManager(p, o, { msgHandler: v, password: s.password, length: h.contentLength, disableAutoFetch: e, rangeChunkSize: s.rangeChunkSize }, t, b); for (let e = 0; e < l.length; e++)i.sendProgressiveData(l[e]); l = []; a.resolve(i); u = null } })).catch((function (e) { a.reject(e); u = null })); var d = 0; new Promise((function (e, o) { var c = function ({ value: e, done: f }) { try { w(); if (f) { i || function () { var e = (0, r.arraysToBytes)(l); s.length && e.length !== s.length && (0, r.warn)("reported HTTP length is different from actual"); try { i = new n.LocalPdfManager(p, e, s.password, t, b); a.resolve(i) } catch (e) { a.reject(e) } l = [] }(); u = null; return } d += (0, r.arrayByteLength)(e); h.isStreamingSupported || v.send("DocProgress", { loaded: d, total: Math.max(d, h.contentLength || 0) }); i ? i.sendProgressiveData(e) : l.push(e); h.read().then(c, o) } catch (e) { o(e) } }; h.read().then(c, o) })).catch((function (e) { a.reject(e); u = null })); u = function (e) { o.cancelAllRequests(e) }; return a.promise } v.on("GetPage", (function (e) { return a.getPage(e.pageIndex).then((function (e) { return Promise.all([a.ensure(e, "rotate"), a.ensure(e, "ref"), a.ensure(e, "userUnit"), a.ensure(e, "view")]).then((function ([e, t, a, r]) { return { rotate: e, ref: t, userUnit: a, view: r } })) })) })); v.on("GetPageIndex", (function (e) { var t = i.Ref.get(e.ref.num, e.ref.gen); return a.pdfDocument.catalog.getPageIndex(t) })); v.on("GetDestinations", (function (e) { return a.ensureCatalog("destinations") })); v.on("GetDestination", (function (e) { return a.ensureCatalog("getDestination", [e.id]) })); v.on("GetPageLabels", (function (e) { return a.ensureCatalog("pageLabels") })); v.on("GetPageLayout", (function (e) { return a.ensureCatalog("pageLayout") })); v.on("GetPageMode", (function (e) { return a.ensureCatalog("pageMode") })); v.on("GetViewerPreferences", (function (e) { return a.ensureCatalog("viewerPreferences") })); v.on("GetOpenAction", (function (e) { return a.ensureCatalog("openAction") })); v.on("GetAttachments", (function (e) { return a.ensureCatalog("attachments") })); v.on("GetJavaScript", (function (e) { return a.ensureCatalog("javaScript") })); v.on("GetOutline", (function (e) { return a.ensureCatalog("documentOutline") })); v.on("GetPermissions", (function (e) { return a.ensureCatalog("permissions") })); v.on("GetMetadata", (function (e) { return Promise.all([a.ensureDoc("documentInfo"), a.ensureCatalog("metadata")]) })); v.on("GetData", (function (e) { a.requestLoadedStream(); return a.onLoadedStream().then((function (e) { return e.bytes })) })); v.on("GetStats", (function (e) { return a.pdfDocument.xref.stats })); v.on("GetAnnotations", (function ({ pageIndex: e, intent: t }) { return a.getPage(e).then((function (e) { return e.getAnnotationsData(t) })) })); v.on("GetOperatorList", (function (e, t) { var i = e.pageIndex; a.getPage(i).then((function (a) { var n = new h("GetOperatorList: page " + i); k(n); const s = f >= r.VerbosityLevel.INFOS ? Date.now() : 0; a.getOperatorList({ handler: v, sink: t, task: n, intent: e.intent, renderInteractiveForms: e.renderInteractiveForms }).then((function (e) { S(n); s && (0, r.info)(`page=${i + 1} - getOperatorList: time=${Date.now() - s}ms, len=${e.length}`); t.close() }), (function (e) { S(n); if (!n.terminated) { v.send("UnsupportedFeature", { featureId: r.UNSUPPORTED_FEATURES.errorOperatorList }); t.error(e) } })) })) }), this); v.on("GetTextContent", (function (e, t) { var i = e.pageIndex; t.onPull = function (e) { }; t.onCancel = function (e) { }; a.getPage(i).then((function (a) { var n = new h("GetTextContent: page " + i); k(n); const s = f >= r.VerbosityLevel.INFOS ? Date.now() : 0; a.extractTextContent({ handler: v, task: n, sink: t, normalizeWhitespace: e.normalizeWhitespace, combineTextItems: e.combineTextItems }).then((function () { S(n); s && (0, r.info)(`page=${i + 1} - getTextContent: time=` + (Date.now() - s) + "ms"); t.close() }), (function (e) { S(n); n.terminated || t.error(e) })) })) })); v.on("FontFallback", (function (e) { return a.fontFallback(e.id, v) })); v.on("Cleanup", (function (e) { return a.cleanup(!0) })); v.on("Terminate", (function (e) { s = !0; const t = []; if (a) { a.terminate(new r.AbortException("Worker was terminated.")); const e = a.cleanup(); t.push(e); a = null } else (0, i.clearPrimitiveCaches)(); u && u(new r.AbortException("Worker was terminated.")); d.forEach((function (e) { t.push(e.finished); e.terminate() })); return Promise.all(t).then((function () { v.destroy(); v = null })) })); v.on("Ready", (function (t) { !function (e) { function t(e) { w(); v.send("GetDoc", { pdfInfo: e }) } function i(e) { w(); if (e instanceof r.PasswordException) { var t = new h("PasswordException: response " + e.code); k(t); v.sendWithPromise("PasswordRequest", e).then((function ({ password: e }) { S(t); a.updatePassword(e); n() })).catch((function () { S(t); v.send("DocException", e) })) } else e instanceof r.InvalidPDFException || e instanceof r.MissingPDFException || e instanceof r.UnexpectedResponseException || e instanceof r.UnknownErrorException ? v.send("DocException", e) : v.send("DocException", new r.UnknownErrorException(e.message, e.toString())) } function n() { w(); C(!1).then(t, (function (e) { w(); if (e instanceof l.XRefParseException) { a.requestLoadedStream(); a.onLoadedStream().then((function () { w(); C(!0).then(t, i) })) } else i(e) }), i) } w(); x(e, { maxImageSize: e.maxImageSize, disableFontFace: e.disableFontFace, ignoreErrors: e.ignoreErrors, isEvalSupported: e.isEvalSupported, fontExtraProperties: e.fontExtraProperties }).then((function (e) { if (s) { e.terminate(new r.AbortException("Worker was terminated.")); throw new Error("Worker was terminated") } (a = e).onLoadedStream().then((function (e) { v.send("DataLoaded", { length: e.bytes.byteLength }) })) })).then(n, i) }(e); e = null })); return y }, initializeFromPort(e) { var t = new o.MessageHandler("worker", "main", e); d.setup(t, e); t.send("ready", null) } }; t.WorkerMessageHandler = d; "undefined" == typeof window && !s.isNodeJS && "undefined" != typeof self && ("function" == typeof (u = self).postMessage && "onmessage" in u) && d.initializeFromPort(self) }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.arrayByteLength = d; t.arraysToBytes = function (e) { const t = e.length; if (1 === t && e[0] instanceof Uint8Array) return e[0]; let a = 0; for (let r = 0; r < t; r++)a += d(e[r]); let r = 0; const i = new Uint8Array(a); for (let a = 0; a < t; a++) { let t = e[a]; t instanceof Uint8Array || (t = "string" == typeof t ? u(t) : new Uint8Array(t)); const n = t.byteLength; i.set(t, r); r += n } return i }; t.assert = o; t.bytesToString = function (e) { o(null !== e && "object" == typeof e && void 0 !== e.length, "Invalid argument for bytesToString"); const t = e.length; if (t < 8192) return String.fromCharCode.apply(null, e); const a = []; for (let r = 0; r < t; r += 8192) { const i = Math.min(r + 8192, t), n = e.subarray(r, i); a.push(String.fromCharCode.apply(null, n)) } return a.join("") }; t.createPromiseCapability = function () { const e = Object.create(null); let t = !1; Object.defineProperty(e, "settled", { get: () => t }); e.promise = new Promise((function (a, r) { e.resolve = function (e) { t = !0; a(e) }; e.reject = function (e) { t = !0; r(e) } })); return e }; t.getVerbosityLevel = function () { return i }; t.info = function (e) { i >= r.INFOS && console.log("Info: " + e) }; t.isArrayBuffer = function (e) { return "object" == typeof e && null !== e && void 0 !== e.byteLength }; t.isArrayEqual = function (e, t) { if (e.length !== t.length) return !1; return e.every((function (e, a) { return e === t[a] })) }; t.isBool = function (e) { return "boolean" == typeof e }; t.isEmptyObj = function (e) { for (const t in e) return !1; return !0 }; t.isNum = function (e) { return "number" == typeof e }; t.isString = function (e) { return "string" == typeof e }; t.isSameOrigin = function (e, t) { let a; try { a = new URL(e); if (!a.origin || "null" === a.origin) return !1 } catch (e) { return !1 } const r = new URL(t, a); return a.origin === r.origin }; t.createValidAbsoluteUrl = function (e, t) { if (!e) return null; try { const a = t ? new URL(e, t) : new URL(e); if (function (e) { if (!e) return !1; switch (e.protocol) { case "http:": case "https:": case "ftp:": case "mailto:": case "tel:": return !0; default: return !1 } }(a)) return a } catch (e) { } return null }; t.removeNullCharacters = function (e) { if ("string" != typeof e) { n("The argument for removeNullCharacters must be a string."); return e } return e.replace(h, "") }; t.setVerbosityLevel = function (e) { Number.isInteger(e) && (i = e) }; t.shadow = c; t.string32 = function (e) { return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e) }; t.stringToBytes = u; t.stringToPDFString = function (e) { const t = e.length, a = []; if ("þ" === e[0] && "ÿ" === e[1]) for (let r = 2; r < t; r += 2)a.push(String.fromCharCode(e.charCodeAt(r) << 8 | e.charCodeAt(r + 1))); else if ("ÿ" === e[0] && "þ" === e[1]) for (let r = 2; r < t; r += 2)a.push(String.fromCharCode(e.charCodeAt(r + 1) << 8 | e.charCodeAt(r))); else for (let r = 0; r < t; ++r) { const t = b[e.charCodeAt(r)]; a.push(t ? String.fromCharCode(t) : e.charAt(r)) } return a.join("") }; t.stringToUTF8String = function (e) { return decodeURIComponent(escape(e)) }; t.utf8StringToString = function (e) { return unescape(encodeURIComponent(e)) }; t.warn = n; t.unreachable = s; t.IsEvalSupportedCached = t.IsLittleEndianCached = t.createObjectURL = t.FormatError = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.TextRenderingMode = t.StreamType = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.MissingPDFException = t.InvalidPDFException = t.AbortException = t.CMapCompressionType = t.ImageKind = t.FontType = t.AnnotationType = t.AnnotationStateModelType = t.AnnotationReviewState = t.AnnotationReplyType = t.AnnotationMarkedState = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationBorderStyleType = t.UNSUPPORTED_FEATURES = t.VerbosityLevel = t.OPS = t.IDENTITY_MATRIX = t.FONT_IDENTITY_MATRIX = t.BaseException = void 0; a(3); t.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; t.FONT_IDENTITY_MATRIX = [.001, 0, 0, .001, 0, 0]; t.PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }; t.TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; t.ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; t.AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; t.AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" }; t.AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" }; t.AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" }; t.AnnotationReplyType = { GROUP: "Group", REPLY: "R" }; t.AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 }; t.AnnotationFieldFlag = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 }; t.AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; t.StreamType = { UNKNOWN: "UNKNOWN", FLATE: "FLATE", LZW: "LZW", DCT: "DCT", JPX: "JPX", JBIG: "JBIG", A85: "A85", AHX: "AHX", CCF: "CCF", RLX: "RLX" }; t.FontType = { UNKNOWN: "UNKNOWN", TYPE1: "TYPE1", TYPE1C: "TYPE1C", CIDFONTTYPE0: "CIDFONTTYPE0", CIDFONTTYPE0C: "CIDFONTTYPE0C", TRUETYPE: "TRUETYPE", CIDFONTTYPE2: "CIDFONTTYPE2", TYPE3: "TYPE3", OPENTYPE: "OPENTYPE", TYPE0: "TYPE0", MMTYPE1: "MMTYPE1" }; const r = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; t.VerbosityLevel = r; t.CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 }; t.OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; t.UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font", errorTilingPattern: "errorTilingPattern", errorExtGState: "errorExtGState", errorXObject: "errorXObject", errorFontLoadType3: "errorFontLoadType3", errorFontState: "errorFontState", errorFontMissing: "errorFontMissing", errorFontTranslate: "errorFontTranslate", errorColorSpace: "errorColorSpace", errorOperatorList: "errorOperatorList", errorFontToUnicode: "errorFontToUnicode", errorFontLoadNative: "errorFontLoadNative", errorFontGetPath: "errorFontGetPath" }; t.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; let i = r.WARNINGS; function n(e) { i >= r.WARNINGS && console.log("Warning: " + e) } function s(e) { throw new Error(e) } function o(e, t) { e || s(t) } function c(e, t, a) { Object.defineProperty(e, t, { value: a, enumerable: !0, configurable: !0, writable: !1 }); return a } const l = function () { function e(t) { this.constructor === e && s("Cannot initialize BaseException."); this.message = t; this.name = this.constructor.name } e.prototype = new Error; e.constructor = e; return e }(); t.BaseException = l; t.PasswordException = class extends l { constructor(e, t) { super(e); this.code = t } }; t.UnknownErrorException = class extends l { constructor(e, t) { super(e); this.details = t } }; t.InvalidPDFException = class extends l { }; t.MissingPDFException = class extends l { }; t.UnexpectedResponseException = class extends l { constructor(e, t) { super(e); this.status = t } }; t.FormatError = class extends l { }; t.AbortException = class extends l { }; const h = /\x00/g; function u(e) { o("string" == typeof e, "Invalid argument for stringToBytes"); const t = e.length, a = new Uint8Array(t); for (let r = 0; r < t; ++r)a[r] = 255 & e.charCodeAt(r); return a } function d(e) { if (void 0 !== e.length) return e.length; o(void 0 !== e.byteLength, "arrayByteLength - invalid argument."); return e.byteLength } const f = { get value() { return c(this, "value", function () { const e = new Uint8Array(4); e[0] = 1; return 1 === new Uint32Array(e.buffer, 0, 1)[0] }()) } }; t.IsLittleEndianCached = f; const g = { get value() { return c(this, "value", function () { try { new Function(""); return !0 } catch (e) { return !1 } }()) } }; t.IsEvalSupportedCached = g; const m = ["rgb(", 0, ",", 0, ",", 0, ")"]; class p { static makeCssRgb(e, t, a) { m[1] = e; m[3] = t; m[5] = a; return m.join("") } static transform(e, t) { return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]] } static applyTransform(e, t) { return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]] } static applyInverseTransform(e, t) { const a = t[0] * t[3] - t[1] * t[2]; return [(e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / a, (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / a] } static getAxialAlignedBoundingBox(e, t) { const a = p.applyTransform(e, t), r = p.applyTransform(e.slice(2, 4), t), i = p.applyTransform([e[0], e[3]], t), n = p.applyTransform([e[2], e[1]], t); return [Math.min(a[0], r[0], i[0], n[0]), Math.min(a[1], r[1], i[1], n[1]), Math.max(a[0], r[0], i[0], n[0]), Math.max(a[1], r[1], i[1], n[1])] } static inverseTransform(e) { const t = e[0] * e[3] - e[1] * e[2]; return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t] } static apply3dTransform(e, t) { return [e[0] * t[0] + e[1] * t[1] + e[2] * t[2], e[3] * t[0] + e[4] * t[1] + e[5] * t[2], e[6] * t[0] + e[7] * t[1] + e[8] * t[2]] } static singularValueDecompose2dScale(e) { const t = [e[0], e[2], e[1], e[3]], a = e[0] * t[0] + e[1] * t[2], r = e[0] * t[1] + e[1] * t[3], i = e[2] * t[0] + e[3] * t[2], n = e[2] * t[1] + e[3] * t[3], s = (a + n) / 2, o = Math.sqrt((a + n) * (a + n) - 4 * (a * n - i * r)) / 2, c = s + o || 1, l = s - o || 1; return [Math.sqrt(c), Math.sqrt(l)] } static normalizeRect(e) { const t = e.slice(0); if (e[0] > e[2]) { t[0] = e[2]; t[2] = e[0] } if (e[1] > e[3]) { t[1] = e[3]; t[3] = e[1] } return t } static intersect(e, t) { function a(e, t) { return e - t } const r = [e[0], e[2], t[0], t[2]].sort(a), i = [e[1], e[3], t[1], t[3]].sort(a), n = []; e = p.normalizeRect(e); t = p.normalizeRect(t); if (!(r[0] === e[0] && r[1] === t[0] || r[0] === t[0] && r[1] === e[0])) return null; n[0] = r[1]; n[2] = r[2]; if (!(i[0] === e[1] && i[1] === t[1] || i[0] === t[1] && i[1] === e[1])) return null; n[1] = i[1]; n[3] = i[2]; return n } } t.Util = p; const b = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364]; const y = function () { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; return function (t, a, r = !1) { if (!r && URL.createObjectURL) { const e = new Blob([t], { type: a }); return URL.createObjectURL(e) } let i = `data:${a};base64,`; for (let a = 0, r = t.length; a < r; a += 3) { const n = 255 & t[a], s = 255 & t[a + 1], o = 255 & t[a + 2]; i += e[n >> 2] + e[(3 & n) << 4 | s >> 4] + e[a + 1 < r ? (15 & s) << 2 | o >> 6 : 64] + e[a + 2 < r ? 63 & o : 64] } return i } }(); t.createObjectURL = y }, function (e, t, a) { "use strict"; a(4) }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.isNodeJS = void 0; const r = "object" == typeof process && process + "" == "[object process]" && !process.versions.nw && !process.versions.electron; t.isNodeJS = r }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.clearPrimitiveCaches = function () { n._clearCache(); i._clearCache(); o._clearCache() }; t.isEOF = function (e) { return e === r }; t.isCmd = function (e, t) { return e instanceof n && (void 0 === t || e.cmd === t) }; t.isDict = u; t.isName = h; t.isRef = function (e) { return e instanceof o }; t.isRefsEqual = function (e, t) { return e.num === t.num && e.gen === t.gen }; t.isStream = function (e) { return "object" == typeof e && null !== e && void 0 !== e.getBytes }; t.RefSetCache = t.RefSet = t.Ref = t.Name = t.Dict = t.Cmd = t.EOF = void 0; a(2); var r = {}; t.EOF = r; var i = function () { let e = Object.create(null); function t(e) { this.name = e } t.prototype = {}; t.get = function (a) { var r = e[a]; return r || (e[a] = new t(a)) }; t._clearCache = function () { e = Object.create(null) }; return t }(); t.Name = i; var n = function () { let e = Object.create(null); function t(e) { this.cmd = e } t.prototype = {}; t.get = function (a) { var r = e[a]; return r || (e[a] = new t(a)) }; t._clearCache = function () { e = Object.create(null) }; return t }(); t.Cmd = n; var s = function () { var e = function () { return e }; function t(t) { this._map = Object.create(null); this.xref = t; this.objId = null; this.suppressEncryption = !1; this.__nonSerializable__ = e } t.prototype = { assignXref: function (e) { this.xref = e }, get(e, t, a) { let r = this._map[e]; if (void 0 === r && void 0 !== t) { r = this._map[t]; void 0 === r && void 0 !== a && (r = this._map[a]) } return r instanceof o && this.xref ? this.xref.fetch(r, this.suppressEncryption) : r }, async getAsync(e, t, a) { let r = this._map[e]; if (void 0 === r && void 0 !== t) { r = this._map[t]; void 0 === r && void 0 !== a && (r = this._map[a]) } return r instanceof o && this.xref ? this.xref.fetchAsync(r, this.suppressEncryption) : r }, getArray(e, t, a) { let r = this.get(e, t, a); if (!Array.isArray(r) || !this.xref) return r; r = r.slice(); for (let e = 0, t = r.length; e < t; e++)r[e] instanceof o && (r[e] = this.xref.fetch(r[e], this.suppressEncryption)); return r }, getRaw: function (e) { return this._map[e] }, getKeys: function () { return Object.keys(this._map) }, set: function (e, t) { this._map[e] = t }, has: function (e) { return void 0 !== this._map[e] }, forEach: function (e) { for (var t in this._map) e(t, this.get(t)) } }; t.empty = new t(null); t.merge = function (e, a) { const r = new t(e); for (let e = 0, t = a.length; e < t; e++) { const t = a[e]; if (u(t)) for (const e in t._map) void 0 === r._map[e] && (r._map[e] = t._map[e]) } return r }; return t }(); t.Dict = s; var o = function () { let e = Object.create(null); function t(e, t) { this.num = e; this.gen = t } t.prototype = { toString: function () { return 0 === this.gen ? this.num + "R" : `${this.num}R${this.gen}` } }; t.get = function (a, r) { const i = 0 === r ? a + "R" : `${a}R${r}`, n = e[i]; return n || (e[i] = new t(a, r)) }; t._clearCache = function () { e = Object.create(null) }; return t }(); t.Ref = o; var c = function () { function e() { this.dict = Object.create(null) } e.prototype = { has: function (e) { return e.toString() in this.dict }, put: function (e) { this.dict[e.toString()] = !0 }, remove: function (e) { delete this.dict[e.toString()] } }; return e }(); t.RefSet = c; var l = function () { function e() { this.dict = Object.create(null) } e.prototype = { get size() { return Object.keys(this.dict).length }, get: function (e) { return this.dict[e.toString()] }, has: function (e) { return e.toString() in this.dict }, put: function (e, t) { this.dict[e.toString()] = t }, putAlias: function (e, t) { this.dict[e.toString()] = this.get(t) }, forEach: function (e) { for (const t in this.dict) e(this.dict[t]) }, clear: function () { this.dict = Object.create(null) } }; return e }(); t.RefSetCache = l; function h(e, t) { return e instanceof i && (void 0 === t || e.name === t) } function u(e, t) { return e instanceof s && (void 0 === t || h(e.get("Type"), t)) } }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.NetworkPdfManager = t.LocalPdfManager = void 0; var r = a(2), i = a(7), n = a(8), s = a(9), o = a(12); class c { constructor() { this.constructor === c && (0, r.unreachable)("Cannot initialize BasePdfManager.") } get docId() { return this._docId } get password() { return this._password } get docBaseUrl() { let e = null; if (this._docBaseUrl) { const t = (0, r.createValidAbsoluteUrl)(this._docBaseUrl); t ? e = t.href : (0, r.warn)(`Invalid absolute docBaseUrl: "${this._docBaseUrl}".`) } return (0, r.shadow)(this, "docBaseUrl", e) } onLoadedStream() { (0, r.unreachable)("Abstract method `onLoadedStream` called") } ensureDoc(e, t) { return this.ensure(this.pdfDocument, e, t) } ensureXRef(e, t) { return this.ensure(this.pdfDocument.xref, e, t) } ensureCatalog(e, t) { return this.ensure(this.pdfDocument.catalog, e, t) } getPage(e) { return this.pdfDocument.getPage(e) } fontFallback(e, t) { return this.pdfDocument.fontFallback(e, t) } cleanup(e = !1) { return this.pdfDocument.cleanup(e) } async ensure(e, t, a) { (0, r.unreachable)("Abstract method `ensure` called") } requestRange(e, t) { (0, r.unreachable)("Abstract method `requestRange` called") } requestLoadedStream() { (0, r.unreachable)("Abstract method `requestLoadedStream` called") } sendProgressiveData(e) { (0, r.unreachable)("Abstract method `sendProgressiveData` called") } updatePassword(e) { this._password = e } terminate(e) { (0, r.unreachable)("Abstract method `terminate` called") } } t.LocalPdfManager = class extends c { constructor(e, t, a, r, i) { super(); this._docId = e; this._password = a; this._docBaseUrl = i; this.evaluatorOptions = r; const n = new o.Stream(t); this.pdfDocument = new s.PDFDocument(this, n); this._loadedStreamPromise = Promise.resolve(n) } async ensure(e, t, a) { const r = e[t]; return "function" == typeof r ? r.apply(e, a) : r } requestRange(e, t) { return Promise.resolve() } requestLoadedStream() { } onLoadedStream() { return this._loadedStreamPromise } terminate(e) { } }; t.NetworkPdfManager = class extends c { constructor(e, t, a, r, n) { super(); this._docId = e; this._password = a.password; this._docBaseUrl = n; this.msgHandler = a.msgHandler; this.evaluatorOptions = r; this.streamManager = new i.ChunkedStreamManager(t, { msgHandler: a.msgHandler, length: a.length, disableAutoFetch: a.disableAutoFetch, rangeChunkSize: a.rangeChunkSize }); this.pdfDocument = new s.PDFDocument(this, this.streamManager.getStream()) } async ensure(e, t, a) { try { const r = e[t]; return "function" == typeof r ? r.apply(e, a) : r } catch (r) { if (!(r instanceof n.MissingDataException)) throw r; await this.requestRange(r.begin, r.end); return this.ensure(e, t, a) } } requestRange(e, t) { return this.streamManager.requestRange(e, t) } requestLoadedStream() { this.streamManager.requestAllChunks() } sendProgressiveData(e) { this.streamManager.onReceiveData({ chunk: e }) } onLoadedStream() { return this.streamManager.onLoadedStream() } terminate(e) { this.streamManager.abort(e) } } }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.ChunkedStreamManager = t.ChunkedStream = void 0; var r = a(2), i = a(8); class n { constructor(e, t, a) { this.bytes = new Uint8Array(e); this.start = 0; this.pos = 0; this.end = e; this.chunkSize = t; this.loadedChunks = []; this.numChunksLoaded = 0; this.numChunks = Math.ceil(e / t); this.manager = a; this.progressiveDataLength = 0; this.lastSuccessfulEnsureByteChunk = -1 } getMissingChunks() { const e = []; for (let t = 0, a = this.numChunks; t < a; ++t)this.loadedChunks[t] || e.push(t); return e } getBaseStreams() { return [this] } allChunksLoaded() { return this.numChunksLoaded === this.numChunks } onReceiveData(e, t) { const a = this.chunkSize; if (e % a != 0) throw new Error("Bad begin offset: " + e); const r = e + t.byteLength; if (r % a != 0 && r !== this.bytes.length) throw new Error("Bad end offset: " + r); this.bytes.set(new Uint8Array(t), e); const i = Math.floor(e / a), n = Math.floor((r - 1) / a) + 1; for (let e = i; e < n; ++e)if (!this.loadedChunks[e]) { this.loadedChunks[e] = !0; ++this.numChunksLoaded } } onReceiveProgressiveData(e) { let t = this.progressiveDataLength; const a = Math.floor(t / this.chunkSize); this.bytes.set(new Uint8Array(e), t); t += e.byteLength; this.progressiveDataLength = t; const r = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize); for (let e = a; e < r; ++e)if (!this.loadedChunks[e]) { this.loadedChunks[e] = !0; ++this.numChunksLoaded } } ensureByte(e) { if (e < this.progressiveDataLength) return; const t = Math.floor(e / this.chunkSize); if (t !== this.lastSuccessfulEnsureByteChunk) { if (!this.loadedChunks[t]) throw new i.MissingDataException(e, e + 1); this.lastSuccessfulEnsureByteChunk = t } } ensureRange(e, t) { if (e >= t) return; if (t <= this.progressiveDataLength) return; const a = this.chunkSize, r = Math.floor(e / a), n = Math.floor((t - 1) / a) + 1; for (let a = r; a < n; ++a)if (!this.loadedChunks[a]) throw new i.MissingDataException(e, t) } nextEmptyChunk(e) { const t = this.numChunks; for (let a = 0; a < t; ++a) { const r = (e + a) % t; if (!this.loadedChunks[r]) return r } return null } hasChunk(e) { return !!this.loadedChunks[e] } get length() { return this.end - this.start } get isEmpty() { return 0 === this.length } getByte() { const e = this.pos; if (e >= this.end) return -1; e >= this.progressiveDataLength && this.ensureByte(e); return this.bytes[this.pos++] } getUint16() { const e = this.getByte(), t = this.getByte(); return -1 === e || -1 === t ? -1 : (e << 8) + t } getInt32() { return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte() } getBytes(e, t = !1) { const a = this.bytes, r = this.pos, i = this.end; if (!e) { i > this.progressiveDataLength && this.ensureRange(r, i); const e = a.subarray(r, i); return t ? new Uint8ClampedArray(e) : e } let n = r + e; n > i && (n = i); n > this.progressiveDataLength && this.ensureRange(r, n); this.pos = n; const s = a.subarray(r, n); return t ? new Uint8ClampedArray(s) : s } peekByte() { const e = this.getByte(); -1 !== e && this.pos--; return e } peekBytes(e, t = !1) { const a = this.getBytes(e, t); this.pos -= a.length; return a } getByteRange(e, t) { e < 0 && (e = 0); t > this.end && (t = this.end); t > this.progressiveDataLength && this.ensureRange(e, t); return this.bytes.subarray(e, t) } skip(e) { e || (e = 1); this.pos += e } reset() { this.pos = this.start } moveStart() { this.start = this.pos } makeSubStream(e, t, a) { t ? e + t > this.progressiveDataLength && this.ensureRange(e, e + t) : e >= this.progressiveDataLength && this.ensureByte(e); function r() { } r.prototype = Object.create(this); r.prototype.getMissingChunks = function () { const e = this.chunkSize, t = Math.floor(this.start / e), a = Math.floor((this.end - 1) / e) + 1, r = []; for (let e = t; e < a; ++e)this.loadedChunks[e] || r.push(e); return r }; r.prototype.allChunksLoaded = function () { return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length }; const i = new r; i.pos = i.start = e; i.end = e + t || this.end; i.dict = a; return i } } t.ChunkedStream = n; t.ChunkedStreamManager = class { constructor(e, t) { this.length = t.length; this.chunkSize = t.rangeChunkSize; this.stream = new n(this.length, this.chunkSize, this); this.pdfNetworkStream = e; this.disableAutoFetch = t.disableAutoFetch; this.msgHandler = t.msgHandler; this.currRequestId = 0; this.chunksNeededByRequest = Object.create(null); this.requestsByChunk = Object.create(null); this.promisesByRequest = Object.create(null); this.progressiveDataLength = 0; this.aborted = !1; this._loadedStreamCapability = (0, r.createPromiseCapability)() } onLoadedStream() { return this._loadedStreamCapability.promise } sendRequest(e, t) { const a = this.pdfNetworkStream.getRangeReader(e, t); a.isStreamingSupported || (a.onProgress = this.onProgress.bind(this)); let i = [], n = 0; new Promise((e, t) => { const s = o => { try { if (!o.done) { const e = o.value; i.push(e); n += (0, r.arrayByteLength)(e); a.isStreamingSupported && this.onProgress({ loaded: n }); a.read().then(s, t); return } const c = (0, r.arraysToBytes)(i); i = null; e(c) } catch (e) { t(e) } }; a.read().then(s, t) }).then(t => { this.aborted || this.onReceiveData({ chunk: t, begin: e }) }) } requestAllChunks() { const e = this.stream.getMissingChunks(); this._requestChunks(e); return this._loadedStreamCapability.promise } _requestChunks(e) { const t = this.currRequestId++, a = Object.create(null); this.chunksNeededByRequest[t] = a; for (const t of e) this.stream.hasChunk(t) || (a[t] = !0); if ((0, r.isEmptyObj)(a)) return Promise.resolve(); const i = (0, r.createPromiseCapability)(); this.promisesByRequest[t] = i; const n = []; for (let e in a) { e |= 0; if (!(e in this.requestsByChunk)) { this.requestsByChunk[e] = []; n.push(e) } this.requestsByChunk[e].push(t) } if (!n.length) return i.promise; const s = this.groupChunks(n); for (const e of s) { const t = e.beginChunk * this.chunkSize, a = Math.min(e.endChunk * this.chunkSize, this.length); this.sendRequest(t, a) } return i.promise } getStream() { return this.stream } requestRange(e, t) { t = Math.min(t, this.length); const a = this.getBeginChunk(e), r = this.getEndChunk(t), i = []; for (let e = a; e < r; ++e)i.push(e); return this._requestChunks(i) } requestRanges(e = []) { const t = []; for (const a of e) { const e = this.getBeginChunk(a.begin), r = this.getEndChunk(a.end); for (let a = e; a < r; ++a)t.includes(a) || t.push(a) } t.sort((function (e, t) { return e - t })); return this._requestChunks(t) } groupChunks(e) { const t = []; let a = -1, r = -1; for (let i = 0, n = e.length; i < n; ++i) { const n = e[i]; a < 0 && (a = n); if (r >= 0 && r + 1 !== n) { t.push({ beginChunk: a, endChunk: r + 1 }); a = n } i + 1 === e.length && t.push({ beginChunk: a, endChunk: n + 1 }); r = n } return t } onProgress(e) { this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e.loaded, total: this.length }) } onReceiveData(e) { const t = e.chunk, a = void 0 === e.begin, i = a ? this.progressiveDataLength : e.begin, n = i + t.byteLength, s = Math.floor(i / this.chunkSize), o = n < this.length ? Math.floor(n / this.chunkSize) : Math.ceil(n / this.chunkSize); if (a) { this.stream.onReceiveProgressiveData(t); this.progressiveDataLength = n } else this.stream.onReceiveData(i, t); this.stream.allChunksLoaded() && this._loadedStreamCapability.resolve(this.stream); const c = []; for (let e = s; e < o; ++e) { const t = this.requestsByChunk[e] || []; delete this.requestsByChunk[e]; for (const a of t) { const t = this.chunksNeededByRequest[a]; e in t && delete t[e]; (0, r.isEmptyObj)(t) && c.push(a) } } if (!this.disableAutoFetch && (0, r.isEmptyObj)(this.requestsByChunk)) { let e; if (1 === this.stream.numChunksLoaded) { const t = this.stream.numChunks - 1; this.stream.hasChunk(t) || (e = t) } else e = this.stream.nextEmptyChunk(o); Number.isInteger(e) && this._requestChunks([e]) } for (const e of c) { const t = this.promisesByRequest[e]; delete this.promisesByRequest[e]; t.resolve() } this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length }) } onError(e) { this._loadedStreamCapability.reject(e) } getBeginChunk(e) { return Math.floor(e / this.chunkSize) } getEndChunk(e) { return Math.floor((e - 1) / this.chunkSize) + 1 } abort(e) { this.aborted = !0; this.pdfNetworkStream && this.pdfNetworkStream.cancelAllRequests(e); for (const t in this.promisesByRequest) this.promisesByRequest[t].reject(e) } } }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.getLookupTableFactory = function (e) { let t; return function () { if (e) { t = Object.create(null); e(t); e = null } return t } }; t.getInheritableProperty = function ({ dict: e, key: t, getArray: a = !1, stopWhenFound: i = !0 }) { let n, s = 0; for (; e;) { const o = a ? e.getArray(t) : e.get(t); if (void 0 !== o) { if (i) return o; n || (n = []); n.push(o) } if (++s > 100) { (0, r.warn)(`getInheritableProperty: maximum loop count exceeded for "${t}"`); break } e = e.get("Parent") } return n }; t.toRomanNumerals = function (e, t = !1) { (0, r.assert)(Number.isInteger(e) && e > 0, "The number should be a positive integer."); const a = []; let i; for (; e >= 1e3;) { e -= 1e3; a.push("M") } i = e / 100 | 0; e %= 100; a.push(o[i]); i = e / 10 | 0; e %= 10; a.push(o[10 + i]); a.push(o[20 + e]); const n = a.join(""); return t ? n.toLowerCase() : n }; t.log2 = function (e) { if (e <= 0) return 0; return Math.ceil(Math.log2(e)) }; t.readInt8 = function (e, t) { return e[t] << 24 >> 24 }; t.readUint16 = function (e, t) { return e[t] << 8 | e[t + 1] }; t.readUint32 = function (e, t) { return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0 }; t.isWhiteSpace = function (e) { return 32 === e || 9 === e || 13 === e || 10 === e }; t.XRefParseException = t.XRefEntryException = t.MissingDataException = void 0; var r = a(2); class i extends r.BaseException { constructor(e, t) { super(`Missing data [${e}, ${t})`); this.begin = e; this.end = t } } t.MissingDataException = i; class n extends r.BaseException { } t.XRefEntryException = n; class s extends r.BaseException { } t.XRefParseException = s; const o = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"] }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.PDFDocument = t.Page = void 0; var r = a(2), i = a(10), n = a(5), s = a(8), o = a(12), c = a(25), l = a(22), h = a(11), u = a(26), d = a(27), f = a(41); const g = [0, 0, 612, 792]; function m(e, t) { return "display" === t && e.viewable || "print" === t && e.printable } class p { constructor({ pdfManager: e, xref: t, pageIndex: a, pageDict: r, ref: i, fontCache: n, builtInCMapCache: s, globalImageCache: o, pdfFunctionFactory: c }) { this.pdfManager = e; this.pageIndex = a; this.pageDict = r; this.xref = t; this.ref = i; this.fontCache = n; this.builtInCMapCache = s; this.globalImageCache = o; this.pdfFunctionFactory = c; this.evaluatorOptions = e.evaluatorOptions; this.resourcesPromise = null; const l = { obj: 0 }; this.idFactory = { createObjId: () => `p${a}_${++l.obj}`, getDocId: () => "g_" + e.docId } } _getInheritableProperty(e, t = !1) { const a = (0, s.getInheritableProperty)({ dict: this.pageDict, key: e, getArray: t, stopWhenFound: !1 }); return Array.isArray(a) ? 1 !== a.length && (0, n.isDict)(a[0]) ? n.Dict.merge(this.xref, a) : a[0] : a } get content() { return this.pageDict.get("Contents") } get resources() { return (0, r.shadow)(this, "resources", this._getInheritableProperty("Resources") || n.Dict.empty) } _getBoundingBox(e) { const t = this._getInheritableProperty(e, !0); if (Array.isArray(t) && 4 === t.length) { if (t[2] - t[0] != 0 && t[3] - t[1] != 0) return t; (0, r.warn)(`Empty /${e} entry.`) } return null } get mediaBox() { return (0, r.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || g) } get cropBox() { return (0, r.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox) } get userUnit() { let e = this.pageDict.get("UserUnit"); (!(0, r.isNum)(e) || e <= 0) && (e = 1); return (0, r.shadow)(this, "userUnit", e) } get view() { const { cropBox: e, mediaBox: t } = this; let a; if (e === t || (0, r.isArrayEqual)(e, t)) a = t; else { const i = r.Util.intersect(e, t); i && i[2] - i[0] != 0 && i[3] - i[1] != 0 ? a = i : (0, r.warn)("Empty /CropBox and /MediaBox intersection.") } return (0, r.shadow)(this, "view", a || t) } get rotate() { let e = this._getInheritableProperty("Rotate") || 0; e % 90 != 0 ? e = 0 : e >= 360 ? e %= 360 : e < 0 && (e = (e % 360 + 360) % 360); return (0, r.shadow)(this, "rotate", e) } getContentStream() { const e = this.content; let t; if (Array.isArray(e)) { const a = this.xref, r = []; for (const t of e) r.push(a.fetchIfRef(t)); t = new o.StreamsSequenceStream(r) } else t = (0, n.isStream)(e) ? e : new o.NullStream; return t } loadResources(e) { this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")); return this.resourcesPromise.then(() => new i.ObjectLoader(this.resources, e, this.xref).load()) } getOperatorList({ handler: e, sink: t, task: a, intent: i, renderInteractiveForms: n }) { const s = this.pdfManager.ensure(this, "getContentStream"), o = this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]), c = new d.PartialEvaluator({ xref: this.xref, handler: e, pageIndex: this.pageIndex, idFactory: this.idFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions, pdfFunctionFactory: this.pdfFunctionFactory }), l = Promise.all([s, o]).then(([r]) => { const n = new u.OperatorList(i, t, this.pageIndex); e.send("StartRenderPage", { transparency: c.hasBlendModes(this.resources), pageIndex: this.pageIndex, intent: i }); return c.getOperatorList({ stream: r, task: a, resources: this.resources, operatorList: n }).then((function () { return n })) }); return Promise.all([l, this._parsedAnnotations]).then((function ([e, t]) { if (0 === t.length) { e.flush(!0); return { length: e.totalLength } } const s = []; for (const e of t) m(e, i) && s.push(e.getOperatorList(c, a, n).catch((function (e) { (0, r.warn)(`getOperatorList - ignoring annotation data during "${a.name}" task: "${e}".`); return null }))); return Promise.all(s).then((function (t) { e.addOp(r.OPS.beginAnnotations, []); for (const a of t) e.addOpList(a); e.addOp(r.OPS.endAnnotations, []); e.flush(!0); return { length: e.totalLength } })) })) } extractTextContent({ handler: e, task: t, normalizeWhitespace: a, sink: r, combineTextItems: i }) { const n = this.pdfManager.ensure(this, "getContentStream"), s = this.loadResources(["ExtGState", "XObject", "Font"]); return Promise.all([n, s]).then(([n]) => new d.PartialEvaluator({ xref: this.xref, handler: e, pageIndex: this.pageIndex, idFactory: this.idFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions, pdfFunctionFactory: this.pdfFunctionFactory }).getTextContent({ stream: n, task: t, resources: this.resources, normalizeWhitespace: a, combineTextItems: i, sink: r })) } getAnnotationsData(e) { return this._parsedAnnotations.then((function (t) { const a = []; for (let r = 0, i = t.length; r < i; r++)e && !m(t[r], e) || a.push(t[r].data); return a })) } get annotations() { return (0, r.shadow)(this, "annotations", this._getInheritableProperty("Annots") || []) } get _parsedAnnotations() { const e = this.pdfManager.ensure(this, "annotations").then(() => { const e = []; for (const t of this.annotations) e.push(c.AnnotationFactory.create(this.xref, t, this.pdfManager, this.idFactory).catch((function (e) { (0, r.warn)(`_parsedAnnotations: "${e}".`); return null }))); return Promise.all(e).then((function (e) { return e.filter(e => !!e) })) }); return (0, r.shadow)(this, "_parsedAnnotations", e) } } t.Page = p; const b = new Uint8Array([37, 80, 68, 70, 45]), y = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), v = new Uint8Array([101, 110, 100, 111, 98, 106]), w = /^[1-9]\.[0-9]$/; function k(e, t, a = 1024, r = !1) { const i = t.length, n = e.peekBytes(a), s = n.length - i; if (s <= 0) return !1; if (r) { const a = i - 1; let r = n.length - 1; for (; r >= a;) { let s = 0; for (; s < i && n[r - s] === t[a - s];)s++; if (s >= i) { e.pos += r - a; return !0 } r-- } } else { let a = 0; for (; a <= s;) { let r = 0; for (; r < i && n[a + r] === t[r];)r++; if (r >= i) { e.pos += a; return !0 } a++ } } return !1 } t.PDFDocument = class { constructor(e, t) { let a; if ((0, n.isStream)(t)) a = t; else { if (!(0, r.isArrayBuffer)(t)) throw new Error("PDFDocument: Unknown argument type"); a = new o.Stream(t) } if (a.length <= 0) throw new r.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes."); this.pdfManager = e; this.stream = a; this.xref = new i.XRef(a, e); this.pdfFunctionFactory = new f.PDFFunctionFactory({ xref: this.xref, isEvalSupported: e.evaluatorOptions.isEvalSupported }); this._pagePromises = [] } parse(e) { this.setup(e); const t = this.catalog.catDict.get("Version"); (0, n.isName)(t) && (this.pdfFormatVersion = t.name); try { this.acroForm = this.catalog.catDict.get("AcroForm"); if (this.acroForm) { this.xfa = this.acroForm.get("XFA"); const e = this.acroForm.get("Fields"); Array.isArray(e) && 0 !== e.length || this.xfa || (this.acroForm = null) } } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)("Cannot fetch AcroForm entry; assuming no AcroForms are present"); this.acroForm = null } try { const e = this.catalog.catDict.get("Collection"); (0, n.isDict)(e) && e.getKeys().length > 0 && (this.collection = e) } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)("Cannot fetch Collection dictionary.") } } get linearization() { let e = null; try { e = h.Linearization.create(this.stream) } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)(e) } return (0, r.shadow)(this, "linearization", e) } get startXRef() { const e = this.stream; let t = 0; if (this.linearization) { e.reset(); k(e, v) && (t = e.pos + 6 - e.start) } else { const a = 1024, r = y.length; let i = !1, n = e.end; for (; !i && n > 0;) { n -= a - r; n < 0 && (n = 0); e.pos = n; i = k(e, y, a, !0) } if (i) { e.skip(9); let a; do { a = e.getByte() } while ((0, s.isWhiteSpace)(a)); let r = ""; for (; a >= 32 && a <= 57;) { r += String.fromCharCode(a); a = e.getByte() } t = parseInt(r, 10); isNaN(t) && (t = 0) } } return (0, r.shadow)(this, "startXRef", t) } checkHeader() { const e = this.stream; e.reset(); if (!k(e, b)) return; e.moveStart(); let t, a = ""; for (; (t = e.getByte()) > 32 && !(a.length >= 12);)a += String.fromCharCode(t); this.pdfFormatVersion || (this.pdfFormatVersion = a.substring(5)) } parseStartXRef() { this.xref.setStartXRef(this.startXRef) } setup(e) { this.xref.parse(e); this.catalog = new i.Catalog(this.pdfManager, this.xref) } get numPages() { const e = this.linearization, t = e ? e.numPages : this.catalog.numPages; return (0, r.shadow)(this, "numPages", t) } get documentInfo() { const e = { Title: r.isString, Author: r.isString, Subject: r.isString, Keywords: r.isString, Creator: r.isString, Producer: r.isString, CreationDate: r.isString, ModDate: r.isString, Trapped: n.isName }; let t = this.pdfFormatVersion; if ("string" != typeof t || !w.test(t)) { (0, r.warn)("Invalid PDF header version number: " + t); t = null } const a = { PDFFormatVersion: t, IsLinearized: !!this.linearization, IsAcroFormPresent: !!this.acroForm, IsXFAPresent: !!this.xfa, IsCollectionPresent: !!this.collection }; let i; try { i = this.xref.trailer.get("Info") } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)("The document information dictionary is invalid.") } if ((0, n.isDict)(i)) for (const t of i.getKeys()) { const s = i.get(t); if (e[t]) e[t](s) ? a[t] = "string" != typeof s ? s : (0, r.stringToPDFString)(s) : (0, r.info)(`Bad value in document info for "${t}".`); else if ("string" == typeof t) { let e; if ((0, r.isString)(s)) e = (0, r.stringToPDFString)(s); else { if (!((0, n.isName)(s) || (0, r.isNum)(s) || (0, r.isBool)(s))) { (0, r.info)(`Unsupported value in document info for (custom) "${t}".`); continue } e = s } a.Custom || (a.Custom = Object.create(null)); a.Custom[t] = e } } return (0, r.shadow)(this, "documentInfo", a) } get fingerprint() { let e; const t = this.xref.trailer.get("ID"); e = Array.isArray(t) && t[0] && (0, r.isString)(t[0]) && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== t[0] ? (0, r.stringToBytes)(t[0]) : (0, l.calculateMD5)(this.stream.getByteRange(0, 1024), 0, 1024); const a = []; for (let t = 0, r = e.length; t < r; t++) { const r = e[t].toString(16); a.push(r.padStart(2, "0")) } return (0, r.shadow)(this, "fingerprint", a.join("")) } _getLinearizationPage(e) { const { catalog: t, linearization: a } = this, i = n.Ref.get(a.objectNumberFirst, 0); return this.xref.fetchAsync(i).then(e => { if ((0, n.isDict)(e, "Page") || (0, n.isDict)(e) && !e.has("Type") && e.has("Contents")) { i && !t.pageKidsCountCache.has(i) && t.pageKidsCountCache.put(i, 1); return [e, i] } throw new r.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.") }).catch(a => { (0, r.info)(a); return t.getPageDict(e) }) } getPage(e) { if (void 0 !== this._pagePromises[e]) return this._pagePromises[e]; const { catalog: t, linearization: a } = this, r = a && a.pageFirst === e ? this._getLinearizationPage(e) : t.getPageDict(e); return this._pagePromises[e] = r.then(([a, r]) => new p({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e, pageDict: a, ref: r, fontCache: t.fontCache, builtInCMapCache: t.builtInCMapCache, globalImageCache: t.globalImageCache, pdfFunctionFactory: this.pdfFunctionFactory })) } checkFirstPage() { return this.getPage(0).catch(async e => { if (e instanceof s.XRefEntryException) { this._pagePromises.length = 0; await this.cleanup(); throw new s.XRefParseException } }) } fontFallback(e, t) { return this.catalog.fontFallback(e, t) } async cleanup(e = !1) { return this.catalog ? this.catalog.cleanup(e) : (0, n.clearPrimitiveCaches)() } } }, function (e, t, a) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); t.FileSpec = t.XRef = t.ObjectLoader = t.Catalog = void 0; var r = a(2), i = a(5), n = a(11), s = a(8), o = a(22), c = a(23), l = a(24); function h(e) { return (0, i.isDict)(e) ? e.get("D") : e } class u { constructor(e, t) { this.pdfManager = e; this.xref = t; this.catDict = t.getCatalogObj(); if (!(0, i.isDict)(this.catDict)) throw new r.FormatError("Catalog object is not a dictionary."); this.fontCache = new i.RefSetCache; this.builtInCMapCache = new Map; this.globalImageCache = new l.GlobalImageCache; this.pageKidsCountCache = new i.RefSetCache } get metadata() { const e = this.catDict.getRaw("Metadata"); if (!(0, i.isRef)(e)) return (0, r.shadow)(this, "metadata", null); const t = !(this.xref.encrypt && this.xref.encrypt.encryptMetadata), a = this.xref.fetch(e, t); let n; if (a && (0, i.isDict)(a.dict)) { const e = a.dict.get("Type"), t = a.dict.get("Subtype"); if ((0, i.isName)(e, "Metadata") && (0, i.isName)(t, "XML")) try { n = (0, r.stringToUTF8String)((0, r.bytesToString)(a.getBytes())) } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)("Skipping invalid metadata.") } } return (0, r.shadow)(this, "metadata", n) } get toplevelPagesDict() { const e = this.catDict.get("Pages"); if (!(0, i.isDict)(e)) throw new r.FormatError("Invalid top-level pages dictionary."); return (0, r.shadow)(this, "toplevelPagesDict", e) } get documentOutline() { let e = null; try { e = this._readDocumentOutline() } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.warn)("Unable to read document outline.") } return (0, r.shadow)(this, "documentOutline", e) } _readDocumentOutline() { let e = this.catDict.get("Outlines"); if (!(0, i.isDict)(e)) return null; e = e.getRaw("First"); if (!(0, i.isRef)(e)) return null; const t = { items: [] }, a = [{ obj: e, parent: t }], n = new i.RefSet; n.put(e); const s = this.xref, o = new Uint8ClampedArray(3); for (; a.length > 0;) { const t = a.shift(), l = s.fetchIfRef(t.obj); if (null === l) continue; if (!l.has("Title")) throw new r.FormatError("Invalid outline item encountered."); const h = { url: null, dest: null }; u.parseDestDictionary({ destDict: l, resultObj: h, docBaseUrl: this.pdfManager.docBaseUrl }); const d = l.get("Title"), f = l.get("F") || 0, g = l.getArray("C"), m = l.get("Count"); let p = o; !Array.isArray(g) || 3 !== g.length || 0 === g[0] && 0 === g[1] && 0 === g[2] || (p = c.ColorSpace.singletons.rgb.getRgb(g, 0)); const b = { dest: h.dest, url: h.url, unsafeUrl: h.unsafeUrl, newWindow: h.newWindow, title: (0, r.stringToPDFString)(d), color: p, count: Number.isInteger(m) ? m : void 0, bold: !!(2 & f), italic: !!(1 & f), items: [] }; t.parent.items.push(b); e = l.getRaw("First"); if ((0, i.isRef)(e) && !n.has(e)) { a.push({ obj: e, parent: b }); n.put(e) } e = l.getRaw("Next"); if ((0, i.isRef)(e) && !n.has(e)) { a.push({ obj: e, parent: t.parent }); n.put(e) } } return t.items.length > 0 ? t.items : null } get permissions() { let e = null; try { e = this._readPermissions() } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.warn)("Unable to read permissions.") } return (0, r.shadow)(this, "permissions", e) } _readPermissions() { const e = this.xref.trailer.get("Encrypt"); if (!(0, i.isDict)(e)) return null; let t = e.get("P"); if (!(0, r.isNum)(t)) return null; t += 2 ** 32; const a = []; for (const e in r.PermissionFlag) { const i = r.PermissionFlag[e]; t & i && a.push(i) } return a } get numPages() { const e = this.toplevelPagesDict.get("Count"); if (!Number.isInteger(e)) throw new r.FormatError("Page count in top-level pages dictionary is not an integer."); return (0, r.shadow)(this, "numPages", e) } get destinations() { const e = this._readDests(), t = Object.create(null); if (e instanceof g) { const a = e.getAll(); for (const e in a) t[e] = h(a[e]) } else e instanceof i.Dict && e.forEach((function (e, a) { a && (t[e] = h(a)) })); return (0, r.shadow)(this, "destinations", t) } getDestination(e) { const t = this._readDests(); return t instanceof g || t instanceof i.Dict ? h(t.get(e) || null) : null } _readDests() { const e = this.catDict.get("Names"); return e && e.has("Dests") ? new g(e.getRaw("Dests"), this.xref) : this.catDict.has("Dests") ? this.catDict.get("Dests") : void 0 } get pageLabels() { let e = null; try { e = this._readPageLabels() } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.warn)("Unable to read page labels.") } return (0, r.shadow)(this, "pageLabels", e) } _readPageLabels() { const e = this.catDict.getRaw("PageLabels"); if (!e) return null; const t = new Array(this.numPages); let a = null, n = ""; const o = new m(e, this.xref).getAll(); let c = "", l = 1; for (let e = 0, h = this.numPages; e < h; e++) { if (e in o) { const t = o[e]; if (!(0, i.isDict)(t)) throw new r.FormatError("PageLabel is not a dictionary."); if (t.has("Type") && !(0, i.isName)(t.get("Type"), "PageLabel")) throw new r.FormatError("Invalid type in PageLabel dictionary."); if (t.has("S")) { const e = t.get("S"); if (!(0, i.isName)(e)) throw new r.FormatError("Invalid style in PageLabel dictionary."); a = e.name } else a = null; if (t.has("P")) { const e = t.get("P"); if (!(0, r.isString)(e)) throw new r.FormatError("Invalid prefix in PageLabel dictionary."); n = (0, r.stringToPDFString)(e) } else n = ""; if (t.has("St")) { const e = t.get("St"); if (!(Number.isInteger(e) && e >= 1)) throw new r.FormatError("Invalid start in PageLabel dictionary."); l = e } else l = 1 } switch (a) { case "D": c = l; break; case "R": case "r": c = (0, s.toRomanNumerals)(l, "r" === a); break; case "A": case "a": const e = 26, t = 65, i = 97, n = "a" === a ? i : t, o = l - 1, h = String.fromCharCode(n + o % e), u = []; for (let t = 0, a = o / e | 0; t <= a; t++)u.push(h); c = u.join(""); break; default: if (a) throw new r.FormatError(`Invalid style "${a}" in PageLabel dictionary.`); c = "" }t[e] = n + c; l++ } return t } get pageLayout() { const e = this.catDict.get("PageLayout"); let t = ""; if ((0, i.isName)(e)) switch (e.name) { case "SinglePage": case "OneColumn": case "TwoColumnLeft": case "TwoColumnRight": case "TwoPageLeft": case "TwoPageRight": t = e.name }return (0, r.shadow)(this, "pageLayout", t) } get pageMode() { const e = this.catDict.get("PageMode"); let t = "UseNone"; if ((0, i.isName)(e)) switch (e.name) { case "UseNone": case "UseOutlines": case "UseThumbs": case "FullScreen": case "UseOC": case "UseAttachments": t = e.name }return (0, r.shadow)(this, "pageMode", t) } get viewerPreferences() { const e = { HideToolbar: r.isBool, HideMenubar: r.isBool, HideWindowUI: r.isBool, FitWindow: r.isBool, CenterWindow: r.isBool, DisplayDocTitle: r.isBool, NonFullScreenPageMode: i.isName, Direction: i.isName, ViewArea: i.isName, ViewClip: i.isName, PrintArea: i.isName, PrintClip: i.isName, PrintScaling: i.isName, Duplex: i.isName, PickTrayByPDFSize: r.isBool, PrintPageRange: Array.isArray, NumCopies: Number.isInteger }, t = this.catDict.get("ViewerPreferences"); let a = null; if ((0, i.isDict)(t)) for (const i in e) { if (!t.has(i)) continue; const n = t.get(i); if (!e[i](n)) { (0, r.info)(`Bad value in ViewerPreferences for "${i}".`); continue } let s; switch (i) { case "NonFullScreenPageMode": switch (n.name) { case "UseNone": case "UseOutlines": case "UseThumbs": case "UseOC": s = n.name; break; default: s = "UseNone" }break; case "Direction": switch (n.name) { case "L2R": case "R2L": s = n.name; break; default: s = "L2R" }break; case "ViewArea": case "ViewClip": case "PrintArea": case "PrintClip": switch (n.name) { case "MediaBox": case "CropBox": case "BleedBox": case "TrimBox": case "ArtBox": s = n.name; break; default: s = "CropBox" }break; case "PrintScaling": switch (n.name) { case "None": case "AppDefault": s = n.name; break; default: s = "AppDefault" }break; case "Duplex": switch (n.name) { case "Simplex": case "DuplexFlipShortEdge": case "DuplexFlipLongEdge": s = n.name; break; default: s = "None" }break; case "PrintPageRange": if (n.length % 2 != 0) break; n.every((e, t, a) => Number.isInteger(e) && e > 0 && (0 === t || e >= a[t - 1]) && e <= this.numPages) && (s = n); break; case "NumCopies": n > 0 && (s = n); break; default: if ("boolean" != typeof n) throw new r.FormatError("viewerPreferences - expected a boolean value for: " + i); s = n }if (void 0 !== s) { a || (a = Object.create(null)); a[i] = s } else (0, r.info)(`Bad value in ViewerPreferences for "${i}".`) } return (0, r.shadow)(this, "viewerPreferences", a) } get openAction() { const e = this.catDict.get("OpenAction"); let t = null; if ((0, i.isDict)(e)) { const a = new i.Dict(this.xref); a.set("A", e); const r = { url: null, dest: null, action: null }; u.parseDestDictionary({ destDict: a, resultObj: r }); if (Array.isArray(r.dest)) { t || (t = Object.create(null)); t.dest = r.dest } else if (r.action) { t || (t = Object.create(null)); t.action = r.action } } else if (Array.isArray(e)) { t || (t = Object.create(null)); t.dest = e } return (0, r.shadow)(this, "openAction", t) } get attachments() { const e = this.catDict.get("Names"); let t = null; if (e && e.has("EmbeddedFiles")) { const a = new g(e.getRaw("EmbeddedFiles"), this.xref).getAll(); for (const e in a) { const i = new p(a[e], this.xref); t || (t = Object.create(null)); t[(0, r.stringToPDFString)(e)] = i.serializable } } return (0, r.shadow)(this, "attachments", t) } get javaScript() { const e = this.catDict.get("Names"); let t = null; function a(e) { const a = e.get("S"); if (!(0, i.isName)(a, "JavaScript")) return; let n = e.get("JS"); if ((0, i.isStream)(n)) n = (0, r.bytesToString)(n.getBytes()); else if (!(0, r.isString)(n)) return; t || (t = []); t.push((0, r.stringToPDFString)(n)) } if (e && e.has("JavaScript")) { const t = new g(e.getRaw("JavaScript"), this.xref).getAll(); for (const e in t) { const r = t[e]; (0, i.isDict)(r) && a(r) } } const n = this.catDict.get("OpenAction"); (0, i.isDict)(n) && (0, i.isName)(n.get("S"), "JavaScript") && a(n); return (0, r.shadow)(this, "javaScript", t) } fontFallback(e, t) { const a = []; this.fontCache.forEach((function (e) { a.push(e) })); return Promise.all(a).then(a => { for (const r of a) if (r.loadedName === e) { r.fallback(t); return } }) } cleanup(e = !1) { (0, i.clearPrimitiveCaches)(); this.globalImageCache.clear(e); this.pageKidsCountCache.clear(); const t = []; this.fontCache.forEach((function (e) { t.push(e) })); return Promise.all(t).then(e => { for (const { dict: t } of e) delete t.translated; this.fontCache.clear(); this.builtInCMapCache.clear() }) } getPageDict(e) { const t = (0, r.createPromiseCapability)(), a = [this.catDict.getRaw("Pages")], n = new i.RefSet, s = this.xref, o = this.pageKidsCountCache; let c, l = 0; !function h() { for (; a.length;) { const u = a.pop(); if ((0, i.isRef)(u)) { c = o.get(u); if (c > 0 && l + c < e) { l += c; continue } if (n.has(u)) { t.reject(new r.FormatError("Pages tree contains circular reference.")); return } n.put(u); s.fetchAsync(u).then((function (r) { if ((0, i.isDict)(r, "Page") || (0, i.isDict)(r) && !r.has("Kids")) if (e === l) { u && !o.has(u) && o.put(u, 1); t.resolve([r, u]) } else { l++; h() } else { a.push(r); h() } }), t.reject); return } if (!(0, i.isDict)(u)) { t.reject(new r.FormatError("Page dictionary kid reference points to wrong type of object.")); return } c = u.get("Count"); if (Number.isInteger(c) && c >= 0) { const t = u.objId; t && !o.has(t) && o.put(t, c); if (l + c <= e) { l += c; continue } } const d = u.get("Kids"); if (!Array.isArray(d)) { if ((0, i.isName)(u.get("Type"), "Page") || !u.has("Type") && u.has("Contents")) { if (l === e) { t.resolve([u, null]); return } l++; continue } t.reject(new r.FormatError("Page dictionary kids object is not an array.")); return } for (let e = d.length - 1; e >= 0; e--)a.push(d[e]) } t.reject(new Error(`Page index ${e} not found.`)) }(); return t.promise } getPageIndex(e) { const t = this.xref; let a = 0; return function n(s) { return function (a) { let n, s = 0; return t.fetchAsync(a).then((function (t) { if ((0, i.isRefsEqual)(a, e) && !(0, i.isDict)(t, "Page") && (!(0, i.isDict)(t) || t.has("Type") || !t.has("Contents"))) throw new r.FormatError("The reference does not point to a /Page dictionary."); if (!t) return null; if (!(0, i.isDict)(t)) throw new r.FormatError("Node must be a dictionary."); n = t.getRaw("Parent"); return t.getAsync("Parent") })).then((function (e) { if (!e) return null; if (!(0, i.isDict)(e)) throw new r.FormatError("Parent must be a dictionary."); return e.getAsync("Kids") })).then((function (e) { if (!e) return null; const o = []; let c = !1; for (let n = 0, l = e.length; n < l; n++) { const l = e[n]; if (!(0, i.isRef)(l)) throw new r.FormatError("Kid must be a reference."); if ((0, i.isRefsEqual)(l, a)) { c = !0; break } o.push(t.fetchAsync(l).then((function (e) { if (!(0, i.isDict)(e)) throw new r.FormatError("Kid node must be a dictionary."); e.has("Count") ? s += e.get("Count") : s++ }))) } if (!c) throw new r.FormatError("Kid reference not found in parent's kids."); return Promise.all(o).then((function () { return [s, n] })) })) }(s).then((function (e) { if (!e) return a; const [t, r] = e; a += t; return n(r) })) }(e) } static parseDestDictionary(e) { const t = e.destDict; if (!(0, i.isDict)(t)) { (0, r.warn)("parseDestDictionary: `destDict` must be a dictionary."); return } const a = e.resultObj; if ("object" != typeof a) { (0, r.warn)("parseDestDictionary: `resultObj` must be an object."); return } const n = e.docBaseUrl || null; let s, o, c = t.get("A"); !(0, i.isDict)(c) && t.has("Dest") && (c = t.get("Dest")); if ((0, i.isDict)(c)) { const e = c.get("S"); if (!(0, i.isName)(e)) { (0, r.warn)("parseDestDictionary: Invalid type in Action dictionary."); return } const t = e.name; switch (t) { case "URI": s = c.get("URI"); (0, i.isName)(s) ? s = "/" + s.name : (0, r.isString)(s) && (s = function (e) { return e.startsWith("www.") ? "http://" + e : e }(s)); break; case "GoTo": o = c.get("D"); break; case "Launch": case "GoToR": const e = c.get("F"); (0, i.isDict)(e) ? s = e.get("F") || null : (0, r.isString)(e) && (s = e); let n = c.get("D"); if (n) { (0, i.isName)(n) && (n = n.name); if ((0, r.isString)(s)) { const e = s.split("#")[0]; (0, r.isString)(n) ? s = e + "#" + n : Array.isArray(n) && (s = e + "#" + JSON.stringify(n)) } } const l = c.get("NewWindow"); (0, r.isBool)(l) && (a.newWindow = l); break; case "Named": const h = c.get("N"); (0, i.isName)(h) && (a.action = h.name); break; case "JavaScript": const u = c.get("JS"); let d; (0, i.isStream)(u) ? d = (0, r.bytesToString)(u.getBytes()) : (0, r.isString)(u) && (d = u); if (d) { const e = new RegExp("^\\s*(" + ["app.launchURL", "window.open"].join("|").split(".").join("\\.") + ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))", "i").exec((0, r.stringToPDFString)(d)); if (e && e[2]) { s = e[2]; "true" === e[3] && "app.launchURL" === e[1] && (a.newWindow = !0); break } } default: (0, r.warn)(`parseDestDictionary: unsupported action type "${t}".`) } } else t.has("Dest") && (o = t.get("Dest")); if ((0, r.isString)(s)) { s = function (e) { try { return (0, r.stringToUTF8String)(e) } catch (t) { return e } }(s); const e = (0, r.createValidAbsoluteUrl)(s, n); e && (a.url = e.href); a.unsafeUrl = s } if (o) { (0, i.isName)(o) && (o = o.name); ((0, r.isString)(o) || Array.isArray(o)) && (a.dest = o) } } } t.Catalog = u; var d = function () { function e(e, t) { this.stream = e; this.pdfManager = t; this.entries = []; this.xrefstms = Object.create(null); this._cacheMap = new Map; this.stats = { streamTypes: Object.create(null), fontTypes: Object.create(null) } } e.prototype = { setStartXRef: function (e) { this.startXRefQueue = [e] }, parse: function (e) { var t; if (e) { (0, r.warn)("Indexing all PDF objects"); t = this.indexObjects() } else t = this.readXRef(); t.assignXref(this); this.trailer = t; let a, n; try { a = t.get("Encrypt") } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.warn)(`XRef.parse - Invalid "Encrypt" reference: "${e}".`) } if ((0, i.isDict)(a)) { var c = t.get("ID"), l = c && c.length ? c[0] : ""; a.suppressEncryption = !0; this.encrypt = new o.CipherTransformFactory(a, l, this.pdfManager.password) } try { n = t.get("Root") } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.warn)(`XRef.parse - Invalid "Root" reference: "${e}".`) } if (!(0, i.isDict)(n) || !n.has("Pages")) { if (!e) throw new s.XRefParseException; throw new r.FormatError("Invalid root reference") } this.root = n }, processXRefTable: function (e) { "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e.lexer.stream.pos, parserBuf1: e.buf1, parserBuf2: e.buf2 }); var t = this.readXRefTable(e); if (!(0, i.isCmd)(t, "trailer")) throw new r.FormatError("Invalid XRef table: could not find trailer dictionary"); var a = e.getObj(); !(0, i.isDict)(a) && a.dict && (a = a.dict); if (!(0, i.isDict)(a)) throw new r.FormatError("Invalid XRef table: could not parse trailer dictionary"); delete this.tableState; return a }, readXRefTable: function (e) { var t, a = e.lexer.stream, n = this.tableState; a.pos = n.streamPos; e.buf1 = n.parserBuf1; e.buf2 = n.parserBuf2; for (; ;) { if (!("firstEntryNum" in n) || !("entryCount" in n)) { if ((0, i.isCmd)(t = e.getObj(), "trailer")) break; n.firstEntryNum = t; n.entryCount = e.getObj() } var s = n.firstEntryNum, o = n.entryCount; if (!Number.isInteger(s) || !Number.isInteger(o)) throw new r.FormatError("Invalid XRef table: wrong types in subsection header"); for (var c = n.entryNum; c < o; c++) { n.streamPos = a.pos; n.entryNum = c; n.parserBuf1 = e.buf1; n.parserBuf2 = e.buf2; var l = {}; l.offset = e.getObj(); l.gen = e.getObj(); var h = e.getObj(); if (h instanceof i.Cmd) switch (h.cmd) { case "f": l.free = !0; break; case "n": l.uncompressed = !0 }if (!Number.isInteger(l.offset) || !Number.isInteger(l.gen) || !l.free && !l.uncompressed) throw new r.FormatError(`Invalid entry in XRef subsection: ${s}, ${o}`); 0 === c && l.free && 1 === s && (s = 0); this.entries[c + s] || (this.entries[c + s] = l) } n.entryNum = 0; n.streamPos = a.pos; n.parserBuf1 = e.buf1; n.parserBuf2 = e.buf2; delete n.firstEntryNum; delete n.entryCount } if (this.entries[0] && !this.entries[0].free) throw new r.FormatError("Invalid XRef table: unexpected first object"); return t }, processXRefStream: function (e) { if (!("streamState" in this)) { var t = e.dict, a = t.get("W"), r = t.get("Index"); r || (r = [0, t.get("Size")]); this.streamState = { entryRanges: r, byteWidths: a, entryNum: 0, streamPos: e.pos } } this.readXRefStream(e); delete this.streamState; return e.dict }, readXRefStream: function (e) { var t, a, i = this.streamState; e.pos = i.streamPos; for (var n = i.byteWidths, s = n[0], o = n[1], c = n[2], l = i.entryRanges; l.length > 0;) { var h = l[0], u = l[1]; if (!Number.isInteger(h) || !Number.isInteger(u)) throw new r.FormatError(`Invalid XRef range fields: ${h}, ${u}`); if (!Number.isInteger(s) || !Number.isInteger(o) || !Number.isInteger(c)) throw new r.FormatError(`Invalid XRef entry fields length: ${h}, ${u}`); for (t = i.entryNum; t < u; ++t) { i.entryNum = t; i.streamPos = e.pos; var d = 0, f = 0, g = 0; for (a = 0; a < s; ++a)d = d << 8 | e.getByte(); 0 === s && (d = 1); for (a = 0; a < o; ++a)f = f << 8 | e.getByte(); for (a = 0; a < c; ++a)g = g << 8 | e.getByte(); var m = {}; m.offset = f; m.gen = g; switch (d) { case 0: m.free = !0; break; case 1: m.uncompressed = !0; break; case 2: break; default: throw new r.FormatError("Invalid XRef entry type: " + d) }this.entries[h + t] || (this.entries[h + t] = m) } i.entryNum = 0; i.streamPos = e.pos; l.splice(0, 2) } }, indexObjects: function () { function e(e, t) { for (var a = "", r = e[t]; 10 !== r && 13 !== r && 60 !== r && !(++t >= e.length);) { a += String.fromCharCode(r); r = e[t] } return a } function t(e, t, a) { for (var r = a.length, i = e.length, n = 0; t < i;) { for (var s = 0; s < r && e[t + s] === a[s];)++s; if (s >= r) break; t++; n++ } return n } var a = /^(\d+)\s+(\d+)\s+obj\b/; const o = /\bendobj[\b\s]$/, c = /\s+(\d+\s+\d+\s+obj[\b\s<])$/; var l = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), h = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]); const u = new Uint8Array([111, 98, 106]); var d = new Uint8Array([47, 88, 82, 101, 102]); this.entries.length = 0; var f = this.stream; f.pos = 0; for (var g, m, p = f.getBytes(), b = f.start, y = p.length, v = [], w = []; b < y;) { var k = p[b]; if (9 !== k && 10 !== k && 13 !== k && 32 !== k) if (37 !== k) { var S, C = e(p, b); if (C.startsWith("xref") && (4 === C.length || /\s/.test(C[4]))) { b += t(p, b, l); v.push(b); b += t(p, b, h) } else if (S = a.exec(C)) { const e = 0 | S[1], a = 0 | S[2]; this.entries[e] && this.entries[e].gen !== a || (this.entries[e] = { offset: b - f.start, gen: a, uncompressed: !0 }); let i, n = b + C.length; for (; n < p.length;) { const e = n + t(p, n, u) + 4; i = e - b; const a = Math.max(e - 25, n), s = (0, r.bytesToString)(p.subarray(a, e)); if (o.test(s)) break; { const e = c.exec(s); if (e && e[1]) { (0, r.warn)('indexObjects: Found new "obj" inside of another "obj", caused by missing "endobj" -- trying to recover.'); i -= e[1].length; break } } n = e } const s = p.subarray(b, b + i); var x = t(s, 0, d); if (x < i && s[x + 5] < 64) { w.push(b - f.start); this.xrefstms[b - f.start] = 1 } b += i } else if (C.startsWith("trailer") && (7 === C.length || /\s/.test(C[7]))) { v.push(b); b += t(p, b, h) } else b += C.length + 1 } else do { if (++b >= y) break; k = p[b] } while (10 !== k && 13 !== k); else ++b } for (g = 0, m = w.length; g < m; ++g) { this.startXRefQueue.push(w[g]); this.readXRef(!0) } let A; for (g = 0, m = v.length; g < m; ++g) { f.pos = v[g]; const e = new n.Parser({ lexer: new n.Lexer(f), xref: this, allowStreams: !0, recoveryMode: !0 }); var I = e.getObj(); if (!(0, i.isCmd)(I, "trailer")) continue; const t = e.getObj(); if (!(0, i.isDict)(t)) continue; let a; try { a = t.get("Root") } catch (e) { if (e instanceof s.MissingDataException) throw e; continue } if ((0, i.isDict)(a) && a.has("Pages")) { if (t.has("ID")) return t; A = t } } if (A) return A; throw new r.InvalidPDFException("Invalid PDF structure.") }, readXRef: function (e) { var t = this.stream; const a = Object.create(null); try { for (; this.startXRefQueue.length;) { var o = this.startXRefQueue[0]; if (a[o]) { (0, r.warn)("readXRef - skipping XRef table since it was already parsed."); this.startXRefQueue.shift(); continue } a[o] = !0; t.pos = o + t.start; const e = new n.Parser({ lexer: new n.Lexer(t), xref: this, allowStreams: !0 }); var c, l = e.getObj(); if ((0, i.isCmd)(l, "xref")) { c = this.processXRefTable(e); this.topDict || (this.topDict = c); l = c.get("XRefStm"); if (Number.isInteger(l)) { var h = l; if (!(h in this.xrefstms)) { this.xrefstms[h] = 1; this.startXRefQueue.push(h) } } } else { if (!Number.isInteger(l)) throw new r.FormatError("Invalid XRef stream header"); if (!Number.isInteger(e.getObj()) || !(0, i.isCmd)(e.getObj(), "obj") || !(0, i.isStream)(l = e.getObj())) throw new r.FormatError("Invalid XRef stream"); c = this.processXRefStream(l); this.topDict || (this.topDict = c); if (!c) throw new r.FormatError("Failed to read XRef stream") } l = c.get("Prev"); Number.isInteger(l) ? this.startXRefQueue.push(l) : (0, i.isRef)(l) && this.startXRefQueue.push(l.num); this.startXRefQueue.shift() } return this.topDict } catch (e) { if (e instanceof s.MissingDataException) throw e; (0, r.info)("(while reading XRef): " + e) } if (!e) throw new s.XRefParseException }, getEntry: function (e) { var t = this.entries[e]; return t && !t.free && t.offset ? t : null }, fetchIfRef: function (e, t) { return e instanceof i.Ref ? this.fetch(e, t) : e }, fetch: function (e, t) { if (!(e instanceof i.Ref)) throw new Error("ref object is not a reference"); const a = e.num, r = this._cacheMap.get(a); if (void 0 !== r) { r instanceof i.Dict && !r.objId && (r.objId = e.toString()); return r } let n = this.getEntry(a); if (null === n) { this._cacheMap.set(a, n); return n } n = n.uncompressed ? this.fetchUncompressed(e, n, t) : this.fetchCompressed(e, n, t); (0, i.isDict)(n) ? n.objId = e.toString() : (0, i.isStream)(n) && (n.dict.objId = e.toString()); return n }, fetchUncompressed(e, t, a = !1) { var r = e.gen, o = e.num; if (t.gen !== r) throw new s.XRefEntryException("Inconsistent generation in XRef: " + e); var c = this.stream.makeSubStream(t.offset + this.stream.start); const l = new n.Parser({ lexer: new n.Lexer(c), xref: this, allowStreams: !0 }); var h = l.getObj(), u = l.getObj(), d = l.getObj(); if (h !== o || u !== r || !(d instanceof i.Cmd)) throw new s.XRefEntryException("Bad (uncompressed) XRef entry: " + e); if ("obj" !== d.cmd) { if (d.cmd.startsWith("obj")) { o = parseInt(d.cmd.substring(3), 10); if (!Number.isNaN(o)) return o } throw new s.XRefEntryException("Bad (uncompressed) XRef entry: " + e) } t = this.encrypt && !a ? l.getObj(this.encrypt.createCipherTransform(o, r)) : l.getObj(); (0, i.isStream)(t) || this._cacheMap.set(o, t); return t }, fetchCompressed(e, t, a = !1) { const o = t.offset, c = this.fetch(i.Ref.get(o, 0)); if (!(0, i.isStream)(c)) throw new r.FormatError("bad ObjStm stream"); const l = c.dict.get("First"), h = c.dict.get("N"); if (!Number.isInteger(l) || !Number.isInteger(h)) throw new r.FormatError("invalid first and n parameters for ObjStm stream"); const u = new n.Parser({ lexer: new n.Lexer(c), xref: this, allowStreams: !0 }), d = new Array(h); for (let e = 0; e < h; ++e) { const t = u.getObj(); if (!Number.isInteger(t)) throw new r.FormatError("invalid object number in the ObjStm stream: " + t); const a = u.getObj(); if (!Number.isInteger(a)) throw new r.FormatError("invalid object offset in the ObjStm stream: " + a); d[e] = t } const f = new Array(h); for (let e = 0; e < h; ++e) { const t = u.getObj(); f[e] = t; u.buf1 instanceof i.Cmd && "endobj" === u.buf1.cmd && u.shift(); if ((0, i.isStream)(t)) continue; const a = d[e], r = this.entries[a]; r && r.offset === o && r.gen === e && this._cacheMap.set(a, t) } if (void 0 === (t = f[t.gen])) throw new s.XRefEntryException("Bad (compressed) XRef entry: " + e); return t }, async fetchIfRefAsync(e, t) { return e instanceof i.Ref ? this.fetchAsync(e, t) : e }, async fetchAsync(e, t) { try { return this.fetch(e, t) } catch (a) { if (!(a instanceof s.MissingDataException)) throw a; await this.pdfManager.requestRange(a.begin, a.end); return this.fetchAsync(e, t) } }, getCatalogObj: function () { return this.root } }; return e }(); t.XRef = d; class f { constructor(e, t, a) { this.constructor === f && (0, r.unreachable)("Cannot initialize NameOrNumberTree."); this.root = e; this.xref = t; this._type = a } getAll() { const e = Object.create(null); if (!this.root) return e; const t = this.xref, a = new i.RefSet; a.put(this.root); const n = [this.root]; for (; n.length > 0;) { const s = t.fetchIfRef(n.shift()); if (!(0, i.isDict)(s)) continue; if (s.has("Kids")) { const e = s.get("Kids"); for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; if (a.has(i)) throw new r.FormatError(`Duplicate entry in "${this._type}" tree.`); n.push(i); a.put(i) } continue } const o = s.get(this._type); if (Array.isArray(o)) for (let a = 0, r = o.length; a < r; a += 2)e[t.fetchIfRef(o[a])] = t.fetchIfRef(o[a + 1]) } return e } get(e) { if (!this.root) return null; const t = this.xref; let a = t.fetchIfRef(this.root), i = 0; for (; a.has("Kids");) { if (++i > 10) { (0, r.warn)(`Search depth limit reached for "${this._type}" tree.`); return null } const n = a.get("Kids"); if (!Array.isArray(n)) return null; let s = 0, o = n.length - 1; for (; s <= o;) { const r = s + o >> 1, i = t.fetchIfRef(n[r]).get("Limits"); if (e < t.fetchIfRef(i[0])) o = r - 1; else { if (!(e > t.fetchIfRef(i[1]))) { a = t.fetchIfRef(n[r]); break } s = r + 1 } } if (s > o) return null } const n = a.get(this._type); if (Array.isArray(n)) { let a = 0, i = n.length - 2; for (; a <= i;) { const r = a + i >> 1, s = r + (1 & r), o = t.fetchIfRef(n[s]); if (e < o) i = s - 2; else { if (!(e > o)) return t.fetchIfRef(n[s + 1]); a = s + 2 } } (0, r.info)(`Falling back to an exhaustive search, for key "${e}", in "${this._type}" tree.`); for (let a = 0, i = n.length; a < i; a += 2) { if (t.fetchIfRef(n[a]) === e) { (0, r.warn)(`The "${e}" key was found at an incorrect, i.e. out-of-order, position in "${this._type}" tree.`); return t.fetchIfRef(n[a + 1]) } } } return null } } class g extends f { constructor(e, t) { super(e, t, "Names") } } class m extends f { constructor(e, t) { super(e, t, "Nums") } } var p = function () { function e(e, t) { if (e && (0, i.isDict)(e)) { this.xref = t; this.root = e; e.has("FS") && (this.fs = e.get("FS")); this.description = e.has("Desc") ? (0, r.stringToPDFString)(e.get("Desc")) : ""; e.has("RF") && (0, r.warn)("Related file specifications are not supported"); this.contentAvailable = !0; if (!e.has("EF")) { this.contentAvailable = !1; (0, r.warn)("Non-embedded file specifications are not supported") } } } function t(e) { return e.has("UF") ? e.get("UF") : e.has("F") ? e.get("F") : e.has("Unix") ? e.get("Unix") : e.has("Mac") ? e.get("Mac") : e.has("DOS") ? e.get("DOS") : null } e.prototype = { get filename() { if (!this._filename && this.root) { var e = t(this.root) || "unnamed"; this._filename = (0, r.stringToPDFString)(e).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/") } return this._filename }, get content() { if (!this.contentAvailable) return null; !this.contentRef && this.root && (this.contentRef = t(this.root.get("EF"))); var e = null; if (this.contentRef) { var a = this.xref.fetchIfRef(this.contentRef); a && (0, i.isStream)(a) ? e = a.getBytes() : (0, r.warn)("Embedded file specification points to non-existing/invalid content") } else (0, r.warn)("Embedded file specification does not have a content"); return e }, get serializable() { return { filename: this.filename, content: this.content } } }; return e }(); t.FileSpec = p; const b = function () { function e(e) { return e instanceof i.Ref || e instanceof i.Dict || Array.isArray(e) || (0, i.isStream)(e) } function t(t, a) { if (t instanceof i.Dict || (0, i.isStream)(t)) { const r = t instanceof i.Dict ? t : t.dict, n = r.getKeys(); for (let t = 0, i = n.length; t < i; t++) { const i = r.getRaw(n[t]); e(i) && a.push(i) } } else if (Array.isArray(t)) for (let r = 0, i = t.length; r < i; r++) { const i = t[r]; e(i) && a.push(i) } } function a(e, t, a) { this.dict = e; this.keys = t; this.xref = a; this.refSet = null } a.prototype = { async load() { if (!this.xref.stream.allChunksLoaded || this.xref.stream.allChunksLoaded()) return; const { keys: e, dict: t } = this; this.refSet = new i.RefSet; const a = []; for (let r = 0, i = e.length; r < i; r++) { const i = t.getRaw(e[r]); void 0 !== i && a.push(i) } return this._walk(a) }, async _walk(e) { const a = [], r = []; for (; e.length;) { let n = e.pop(); if (n instanceof i.Ref) { if (this.refSet.has(n)) continue; try { this.refSet.put(n); n = this.xref.fetch(n) } catch (e) { if (!(e instanceof s.MissingDataException)) throw e; a.push(n); r.push({ begin: e.begin, end: e.end }) } } if (n && n.getBaseStreams) { const e = n.getBaseStreams(); let t = !1; for (let a = 0, i = e.length; a < i; a++) { const i = e[a]; if (i.allChunksLoaded && !i.allChunksLoaded()) { t = !0; r.push({ begin: i.start, end: i.end }) } } t && a.push(n) } t(n, e) } if (r.length) { await this.xref.stream.manager.requestRanges(r); for (let e = 0, t = a.length; e < t; e++) { const t = a[e];t i